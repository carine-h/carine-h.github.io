---
title: "blog_pred"
author: "Carine Hajjar"
date: "10/28/2020"
output: html_document
---

```{r setup, include=FALSE}

library(tidyverse)
library(ggplot2)
library(statebins)
library(stargazer)
library(cowplot)
library(gt)
library(readr)
library(reshape2)
library(statebins)
library(jtools)


knitr::opts_chunk$set(echo = TRUE)
popvote_df    <- read_csv("/Users/carinehajjar/Desktop/R studio/carine-h.github.io/data/popvote_1948-2016.csv")
# 538
pvstate_df    <- read_csv("/Users/carinehajjar/Desktop/R studio/carine-h.github.io/data/popvote_bystate_1948-2016.csv")
economy_df    <- read_csv("/Users/carinehajjar/Desktop/R studio/carine-h.github.io/data/econ.csv")
approval_df   <- read_csv("/Users/carinehajjar/Desktop/R studio/carine-h.github.io/data/approval_gallup_1941-2020.csv")
# 538
pollstate_df  <- read_csv("/Users/carinehajjar/Desktop/R studio/carine-h.github.io/data/pollavg_bystate_1968-2016.csv")
state_pv_df<- read_csv("pred_data/popvote_bystate_1948-2016 copy 2.csv")
app <- read_csv("data/approval_gallup_1941-2020.csv")
# 538: 2020 poll averages per state 
poll_2020_state <- read_csv("/Users/carinehajjar/Desktop/R studio/carine-h.github.io/pred_data/presidential_poll_averages_2020.csv")
econ_update <- read_csv("pred_data/econ_update.csv")
demog <- read_csv("~/Desktop/R studio/carine-h.github.io/data/demographic_1990-2018.csv")
pvstate_df    <- read_csv("~/Desktop/R studio/carine-h.github.io/data/popvote_bystate_1948-2016.csv")
pollstate_df  <- read_csv("~/Desktop/R studio/carine-h.github.io/data/pollavg_bystate_1968-2016.csv")
hispanic_2020 <- read_csv("~/Desktop/R studio/carine-h.github.io/data/csvData.csv")
race_2020 <- read_csv("~/Desktop/R studio/carine-h.github.io/data/demog_race.csv")
electoral_votes <- read_csv("~/Desktop/R studio/carine-h.github.io/data/electoralcollegevotes_1948-2020.csv")

# tidyinig electoral votes for my purposes 
electoral <- electoral_votes %>%
  select(X1, '2020') %>%
  rename(state = X1) %>%
  mutate(state = state.abb[match(state,state.name)]) %>%
  na.omit() 
```


# Time-For-Change Model: NATIONAL
```{r}
# cleaning and joining data 
tfc_df <- popvote_df %>%
  filter(incumbent_party) %>%
  select(year, candidate, party, pv, pv2p, incumbent) %>%
  inner_join(
    approval_df %>% 
      group_by(year, president) %>% 
      slice(1) %>% 
      # this is a NET APPROVAL
      mutate(net_approve=approve-disapprove) %>% 
      select(year, incumbent_pres=president, net_approve, poll_enddate),
    by="year"
  ) %>%
  inner_join(
    economy_df %>%
      # SECOND QUARTER GDP
      filter(quarter == 2) %>%
      select(GDP_growth_qt, year, RDI_growth, quarter),
    by="year"
  )


fit_tfc <- lm(pv2p ~ GDP_growth_qt + net_approve + incumbent, data = tfc_df)
summary(fit_tfc)

approval_df

export_summs(fit_tfc, model.names = "Time-for-Change Model: \n Relationship Between Popular Vote, \n GDP Growth, Net Approval, and Incumbency")

# 2020 second-quarter GDP
economy_df %>%
  select(year, quarter, GDP_growth_qt, RDI_growth) %>%
  filter(year == 2020, 
         quarter == 3)
# 2020 second quarter approval
approval_df %>%
  filter(year == 2020) %>%
  unique() %>%
  filter(poll_startdate >= as.POSIXct("2020-04-01"), 
         poll_enddate <= as.POSIXct("2020-06-30")) %>%
  mutate(net_approval = approve - disapprove) %>%
  summarise(net = mean(net_approval))


# Time for Change Prediction 
a <- -9.494716	
b <- -8.5 # according to Gallup in 2nd quarter
c <- TRUE

new_data <- data.frame(year = 2020, candidate = "Donald J. Trump", party = "republican", pv = NA, pv2p = NA, incumbent = TRUE, incumbent_pres = NA, net_approve = b, poll_enddate = NA, GDP_growth_qt = a, RDI_growth = NA, quarter = 2, color = "red")
  # - 31.4 decline 
  # net approval: -10.2



predict(fit_tfc, newdata = new_data)

# Model Predicts Trump will get 32.43% of the vote share which is almost certainly a loss 


# IN SAMPLE: adjusted R squared is 0.62: 62% of variance is explained by the model 

# OUT OF SAMPLE: 
# creating color vector for party id 
tfc_df$color[tfc_df$party== "republican"]="red"
tfc_df$color[tfc_df$party== "democrat"]="blue"

# plotting residuals of TFC
plot(tfc_df$year, tfc_df$pv2p, type = "l", 
     main = "Time-For-Change Model: \n True Popular Vote vs. Predicted Popular Vote", 
     xlab = "Year", 
     ylab = "Popular Vote Share",
     ylim = c(40, 65), 
     xlim = c(1950, 2020))
# predicted points
points(tfc_df$year, predict(fit_tfc, tfc_df), 
       col = tfc_df$color)
# legend formatting
legend("topright", 
       legend = c("Actual Outcomes", "Predicted Outcomes", "   Republican", "   Democrat"), 
       col = c("black", "black", "red", "blue"), 
       lwd=1, 
       lty=c(1,NA,NA,NA), 
       pch=c(NA,1,1,1), 
       merge=FALSE, 
       cex = 0.7)

# outsample errors for tfc model
outsamp_errors <- sapply(1:1000, function(i){
years_outsamp <- sample(tfc_df$year, 8)
outsamp_mod <- lm(pv2p ~ GDP_growth_qt + net_approve + incumbent, tfc_df[!(tfc_df$year %in% years_outsamp),])
outsamp_pred <- predict(outsamp_mod, 
                        newdata = tfc_df[tfc_df$year %in% years_outsamp,])
outsamp_true <- tfc_df$pv2p[tfc_df$year %in% years_outsamp]
mean(outsamp_pred - outsamp_true)
})

# visualize in histogram
hist(outsamp_errors,
     xlab = "Out-of-Sample Residual",
     main = "Time-for-Change Model: \n Mean Out-of-Sample Residual (1000 Runs)",
     xlim = c(-15, 15), 
     ylim = c(0, 270))

# quantify by taking the means of the outsample errors 
mean(abs(outsamp_errors))
```
# Models for my weighted ensemble: 
  - polls/approval: polls AND approval rating  
  - economic: jobs, UE, GDP
  - demographic: already done
  - something for COVID?
  - incumbent

## POLLS 
Using polls from 3 weeks out and predicted with 2020 average polls in each state from 10/8 to today (also three weeks)
```{r}
dat <- state_pv_df %>% 
  full_join(poll_state_df %>% 
              filter(weeks_left == 3) %>% 
              group_by(year,party,state) %>% 
              summarise(avg_poll=mean(avg_poll)),
            by = c("year" ,"state")) 
## model 
fit_state_poll <- lm(D_pv2p ~ avg_poll + as.factor(state), data = dat)

## prediction : take the average for each state
    # average of three weeks ago: October 8
new_data_poll <- poll_2020_state %>%
  mutate(date = as.Date(modeldate, format = "%m/%d/%Y")) %>%
  filter(date >= as.Date("2020-10-08")) %>%
  rename(year = cycle) %>%
  group_by(state) %>%
  summarize(avg_poll = mean(pct_estimate)) %>%
  filter(state != "ME-1", 
         state != "ME-2",
         state != "NE-1", 
         state != "NE-2", 
         state != "National") 

pred_2020 <- predict(poll_fit, newdata = new_data_poll)
# if it's greater than 50, it's Biden, if it's less, it's Trump 
poll_pred_2020 <- tibble(state = new_data_poll$state, pred = poll_pred_2020)
his%>%  ##`statebins` needs state to be character, not factor!
  mutate(state = as.character(state)) %>%
  ggplot(aes(state = state, fill = (pred >= 50))) +
  geom_statebins() +
  theme_statebins() +
  labs(title = "Original 2020 Popular Vote Prediction",
       subtitle = "Demographic Change Effect \n Using 2016-2018 Demographic Shifts",
       fill = "") +
  theme(legend.position = "none", 
        plot.subtitle = element_text(size = 10, hjust = 0.5),
        plot.title   = element_text(size = 12, hjust = 0.5, face = "bold"))


his %>%
  mutate(state_win = case_when(pred > 50 ~ "Biden",
                            pred < 50 ~ "Trump")) %>%
  na.omit()
```


# DEMOGRAPHICS
```{r}
# state names and abbreviations
pvstate_df$state <- state.abb[match(pvstate_df$state, state.name)]
pollstate_df$state <- state.abb[match(pollstate_df$state, state.name)]

dat <- pvstate_df %>% 
  full_join(pollstate_df %>% 
              filter(weeks_left == 3) %>% 
              group_by(year,party,state) %>% 
              summarise(avg_poll=mean(avg_poll)),
            by = c("year" ,"state")) %>%
  left_join(demog %>%
              select(-c("total")),
            by = c("year" ,"state"))
# demographics, poll numbers, and popular vote 

dat$region <- state.division[match(dat$state, state.abb)]
demog$region <- state.division[match(demog$state, state.abb)]

dat_change <- dat %>%
  group_by(state) %>%
  mutate(Asian_change = Asian - lag(Asian, order_by = year),
         Black_change = Black - lag(Black, order_by = year),
         Hispanic_change = Hispanic - lag(Hispanic, order_by = year),
         Indigenous_change = Indigenous - lag(Indigenous, order_by = year),
         White_change = White - lag(White, order_by = year),
         Female_change = Female - lag(Female, order_by = year),
         Male_change = Male - lag(Male, order_by = year),
         age20_change = age20 - lag(age20, order_by = year),
         age3045_change = age3045 - lag(age3045, order_by = year),
         age4565_change = age4565 - lag(age4565, order_by = year),
         age65_change = age65 - lag(age65, order_by = year)
  )

# new data for 2020
demog_2020 <- subset(demog, year == 2018)
demog_2020 <- as.data.frame(demog_2020)
rownames(demog_2020) <- demog_2020$state
demog_2020 <- demog_2020[state.abb, ] # prints regions of the US 

# calculating demographic changes from 2016-2018
demog_2020_change <- demog %>%
  filter(year %in% c(2016, 2018)) %>%
  group_by(state) %>%
  mutate(Asian_change = Asian - lag(Asian, order_by = year), # CALCULATING CHANGES IN POPULATION
         Black_change = Black - lag(Black, order_by = year),
         Hispanic_change = Hispanic - lag(Hispanic, order_by = year),
         Indigenous_change = Indigenous - lag(Indigenous, order_by = year),
         White_change = White - lag(White, order_by = year),
         Female_change = Female - lag(Female, order_by = year),
         Male_change = Male - lag(Male, order_by = year),
         age20_change = age20 - lag(age20, order_by = year),
         age3045_change = age3045 - lag(age3045, order_by = year),
         age4565_change = age4565 - lag(age4565, order_by = year),
         age65_change = age65 - lag(age65, order_by = year)
  ) %>%
  filter(year == 2018)

demog_2020_change <- as.data.frame(demog_2020_change)
rownames(demog_2020_change) <- demog_2020_change$state
demog_2020_change <- demog_2020_change[state.abb, ]


mod_demog_change <- lm(D_pv2p ~ Black_change + Hispanic_change + Asian_change +
                         as.factor(state), data = dat_change)

summary(mod_demog_change)



# 2020 NEW DATA
# updated demographics
dat_2020 <- race_2020 %>%
  left_join(hispanic_2020, by = "State") %>%
  mutate(Hispanic = 100*HispanicPerc, 
         state = State, 
         White = 100*WhitePerc, 
         Asian = 100*AsianPerc, 
         Black = 100*BlackPerc) %>%
  select(state, Hispanic, White, Asian, Black) %>%
  mutate(state = state.abb[match(state,state.name)]) %>%
  na.omit() %>%
  mutate(year = 2020)

# 2018 demographics
dat_2018 <- demog %>%
  filter(year == 2018) 

# joining demographics
real_2020_change <- bind_rows(dat_2018, dat_2020)

# calculating percent changes in available demographic groups
## I used 0 percent change with populations that lacked demographic data (age and gender)
real_2020 <- real_2020_change %>%
  filter(year %in% c(2018, 2020)) %>%
  group_by(state) %>%
  mutate(Asian_change = Asian - lag(Asian, order_by = year), # CALCULATING CHANGES IN POPULATION
         Black_change = Black - lag(Black, order_by = year),
         Hispanic_change = Hispanic - lag(Hispanic, order_by = year),
         Indigenous_change = 0,
         White_change = White - lag(White, order_by = year),
         Female_change = 0,
         Male_change = 0,
         age20_change = 0,
         age3045_change = 0,
         age4565_change = 0,
         age65_change = 0) %>%
  filter(year == 2020)

real_2020 <- as.data.frame(real_2020)
rownames(real_2020) <- real_2020$state
real_2020 <- real_2020[state.abb, ]
real_2020$region <- state.division[match(real_2020$state, state.abb)]

# predict
demog_pred <- predict(mod_demog_change, newdata = real_2020)

```

# ECONOMICS
```{r}
state_gdp <- read_csv("pred_data/state_gdp_quarter.csv")

# going to have to use yearly growth
state_econ <- state_gdp %>%
  select(GeoName, LineCode, '2008', '2009', '2010', '2011', '2012', '2013', '2014', '2015', '2016', '2017', '2018')%>%
  melt(c("GeoName", "LineCode"), value.name = "GDP") %>%
  mutate(year = as.numeric(as.character(variable))) %>%
  rename(state = GeoName) %>%
  group_by(state, year) %>%
  mutate(gdp_growth= (GDP - lag(GDP, order_by = c(year)))/lag(GDP, order_by = c(year))) %>%
  mutate(state = state.abb[match(state,state.name)]) %>%
  select(year, LineCode, state, gdp_growth) %>%
  filter(year %in% c(2008, 2012, 2016))

q3_econ <- pvstate_df %>%
  left_join(state_econ, by = c("year", "state")) %>%
  left_join(pv, by = c("year")) %>%
  filter(LineCode == 3) %>%
  rename("quarter" = "LineCode") %>%
  na.omit()
  
econ_fit <- lm(D_pv2p ~ gdp_growth + incumbent + as.factor(state), data = q3_econ)
summary(econ_fit)

# new data
new_data_econ <- state_econ %>%
  select(state) %>%
  mutate(year = 2020) %>%
  na.omit()%>%
  distinct(state) %>%
  mutate(gdp_growth = 0.38, 
         quarter = 3,
         incumbent = TRUE)

econ_pred <- predict(econ_fit, newdata = new_data_econ)
```


```{r}

  # - 31.4 decline 
  # net approval: -10.2



0.25*econ_pred + 0.25*demog_pred + 0.5*poll_pred_2020$pred
 # now make equal lengths 
 # change state names
 # do predictions and fits
```



# COMPARINIG MODELS
```{r}
# ELECTORALS
electoral_votes <- read_csv("~/Desktop/R studio/carine-h.github.io/data/electoralcollegevotes_1948-2020.csv")
# tidyinig electoral votes for my purposes 
electoral <- electoral_votes %>%
  select(X1, '2020') %>%
  rename(state = X1) %>%
  mutate(state = state.abb[match(state,state.name)]) %>%
  na.omit() 


#################
# compare models
#################  
# POLL MODEL
export_summs(fit_state_poll)

poll_pred_2020 %>%
  rename("pred" = "predict(poll_fit, newdata = new_data_poll)") %>%
  mutate(state = rownames(poll_pred_2020), 
         state = state.abb[match(state,state.name)])%>%
  select(state, pred) %>%
  left_join(electoral, by = "state") %>%
  mutate(state_win = case_when(pred > 50 ~ "Biden",
                            pred < 50 ~ "Trump")) %>%
  na.omit()%>%
  group_by(state_win) %>%
  summarise(electoral_votes = sum(`2020`)) %>%
  gt() %>%
  tab_header(title = md("**2020 Electoral Vote Outcome Using 2020 3 Week Poll Model**"), 
               subtitle = "Biden Wins") %>%
   cols_label(state_win = md("**Candidate**"),
               electoral_votes = md("**Total Electoral Votes**")) %>%
  tab_source_note(md("*Data: World Population Review*"))

# DEMOG MODEL
export_summs(mod_demog_change)

demo_pred_2020 %>%
  rename("pred" = "predict(mod_demog_change, newdata = real_2020)") %>%
  select(state, pred) %>%
  left_join(electoral, by = "state") %>%
  mutate(state_win = case_when(pred > 50 ~ "Biden",
                            pred < 50 ~ "Trump")) %>%
  na.omit()%>%
  group_by(state_win) %>%
  summarise(electoral_votes = sum(`2020`)) %>%
  gt() %>%
  tab_header(title = md("**2020 Electoral Vote Outcome Using 2020 Demographic Model**"), 
               subtitle = "Biden Wins") %>%
   cols_label(state_win = md("**Candidate**"),
               electoral_votes = md("**Total Electoral Votes**")) %>%
  tab_source_note(md("*Data: World Population Review*"))

# MODIFIED TFC
export_summs(econ_fit)

```



# Weighted Ensemble
- I am placing the most weight on polls, 
- have as.factor state for each poll 

in sample fit: 
.5(poll)+.25(econ)+.25(demo)
true value - (.5(poll)+.25(econ)+.25(demo))
0.5predict() + 0.25predict() + .25predict()

out of sample fit: 
- exclude 2016 and then do whole process and do regression parameter without 2016
  - predict with ensemble fit (without 2016) and make new data = 2016 data  
- make sure new data has a column named state and states listed 

There should be a column named “state”
And ex. PA? Then your new data should have “state” column with “PA” in that column
True value - (0.5x51 + 0.25x49 + 0.25x50)


you could do ensemble at the electoral college level (0.5x400 + 0.25x390 + 0.25x380)



# Modified Time-For-Change
- economic approval rating 
- state AND national approval
- GDP/RDI Growth 
- Incumbency
- Jobs 
- 2020 demographics 
- predict national pop_vote

polls model and demographic will have popular vote share from state 

- state poll, demo, AND economic model
- maybe add incumbency indicator to either poll or economy 
  - find link on slack 
















```{r}
#####------------------------------------------------------#
#####  Describe data ####
#####------------------------------------------------------#

## Bivariate correlations:
## do unemployment increases correlate with incumbent punishment?
cor(pvstate_local$Unemployed_up, pvstate_local$state_incwin, use="pairwise")
cor(pvstate_local$Unemployed_up, pvstate_local$state_incpv2p, use="pairwise")

## Bivariate correlations *by party*:
## is the above stronger for incumbents of one party than another?
{
par(mfrow=c(2,1))
plot(pvstate_local$Unemployed_up[pvstate_local$incparty == "republican"], 
     pvstate_local$state_incpv2p[pvstate_local$incparty == "republican"],
     main = "When Republicans Are\nthe Incumbent Party...",
     xlab="unemployment % increase", ylab="two-party vote-share")
plot(pvstate_local$Unemployed_up[pvstate_local$incparty == "democrat"], 
     pvstate_local$state_incpv2p[pvstate_local$incparty == "democrat"],
     main = "When Democrats Are\nthe Incumbent Party...",
     xlab="unemployment % increase", ylab="two-party vote-share")
}

cor(pvstate_local$Unemployed_up[pvstate_local$incparty == "republican"], 
    pvstate_local$state_incpv2p[pvstate_local$incparty == "republican"], use="pairwise")
cor(pvstate_local$Unemployed_up[pvstate_local$incparty == "democrat"], 
    pvstate_local$state_incpv2p[pvstate_local$incparty == "democrat"], use="pairwise")
```


```{r}
#####------------------------------------------------------#
#####  New option: Weighted Ensemble ####
#####------------------------------------------------------#

## Ensemble 1: polls and fundamentals matter equally as much
pwt <- 0.5; ewt <- 0.5;
pwt*predict(mod_poll_inc, dat_2020_inc) + ewt*predict(mod_econ_inc, dat_2020_inc)
pwt*predict(mod_poll_chl, dat_2020_chl) + ewt*predict(mod_econ_chl, dat_2020_chl)

## Ensemble 2: polls matter closer to November 
## (what Nate Silver thinks)
days_left <- 40
pwt <- 1/sqrt(days_left); ewt <- 1-(1/sqrt(days_left));
plot(100:1, 1/sqrt(100:1), xlim=c(100, 0), type="l", 
     ylab="poll model weight", xlab="days til elxn")

pwt*predict(mod_poll_inc, dat_2020_inc) + ewt*predict(mod_econ_inc, dat_2020_inc) # adjusted poll
pwt*predict(mod_poll_chl, dat_2020_chl) + ewt*predict(mod_econ_chl, dat_2020_chl) # adjusted poll

pwt*dat_2020_inc$avg_support + ewt*predict(mod_econ_inc, dat_2020_inc) # raw poll
pwt*dat_2020_chl$avg_support + ewt*predict(mod_econ_chl, dat_2020_chl) # raw poll

## Ensemble 3: fundamentals matter closer to November 
## (what Gelman & King (1993) think)
days_left <- 42
pwt <- 1-(1/sqrt(days_left)); ewt <- 1/sqrt(days_left);
pwt*predict(mod_poll_inc, dat_2020_inc) + ewt*predict(mod_econ_inc, dat_2020_inc)
pwt*predict(mod_poll_chl, dat_2020_chl) + ewt*predict(mod_econ_chl, dat_2020_chl)

## Ensemble 4: weight models based on their historical performance
pwt <- colMeans(outsamp_df,na.rm=T)["poll_winner_correct"]; 
ewt <- colMeans(outsamp_df, na.rm=T)["econ_winner_correct"];
(pwt/(pwt+ewt))*predict(mod_poll_inc, dat_2020_inc) + (ewt/(pwt+ewt))*predict(mod_econ_inc, dat_2020_inc)
(pwt/(pwt+ewt))*predict(mod_poll_chl, dat_2020_chl) + (ewt/(pwt+ewt))*predict(mod_econ_chl, dat_2020_chl)

```

